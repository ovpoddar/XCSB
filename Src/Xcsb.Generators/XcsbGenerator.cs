using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;

namespace Xcsb.Generators
{
    [Generator(LanguageNames.CSharp)]
    internal sealed class XcsbGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var extensationDefineAttributes = context.CompilationProvider
                .Select((a, _) => a.GetTypeByMetadataName("Xcsb.Generators.Attributes.XExtensationExporterAttribute"));
            var extensationAssemblys = context.CompilationProvider
                    .Select((a, _) =>
                        a.References
                            .Select(r => a.GetAssemblyOrModuleSymbol(r)).OfType<IAssemblySymbol>()
                            .Where(a => a.Identity.Name.StartsWith("Xcsb"))
                            .ToImmutableArray());
            var exportedInterfaces = extensationAssemblys
                .Combine(extensationDefineAttributes)
                .Select((pair, _) =>
                    pair.Left.SelectMany(a => GetAllTypes(a.GlobalNamespace))
                        .Where(t => pair.Right is not null
                                    && t.TypeKind == TypeKind.Interface
                                    && t.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, pair.Right)))
                        .Distinct(SymbolEqualityComparer.Default)                        
                        .ToImmutableArray());

            //Debugger.Launch();

            context.RegisterSourceOutput(exportedInterfaces, (ctx, packets) =>
            {
                ctx.AddSource("IXCProto.g.cs",
$$"""
// <auto-generated/>
namespace Xcsb
{

    public interface IXCProto
    {
        void Write();
    }

    public class XCpo : IXCProto
    {
        public void Write()
        {
            Console.WriteLine("{{String.Join(", ", packets.Where(a => a is not null).Select(a => a.ToDisplayString()))}}");
        }
    }
}

""");

                ctx.AddSource("XcsbClient.g.cs",
$$"""
namespace Xcsb
{

    public static class Charactor
    {
        public static IXCProto Dismember(this Xcsb.IXProto client)
        {
            return new XCpo();
        }
    }
}

""");
            });

            //            context.RegisterPostInitializationOutput((ctx) =>
            //            {
            //                ctx.AddSource("IXCProto.g.cs",
            //$$"""
            //// <auto-generated/>
            //namespace Xcsb
            //{

            //    public interface IXCProto
            //    {
            //        void Write();
            //    }

            //    public class XCpo : IXCProto
            //    {
            //        public void Write()
            //        {
            //            Console.WriteLine("Hellow");
            //        }
            //    }
            //}

            //""");

            //                ctx.AddSource("XcsbClient.g.cs",
            //$$"""
            //namespace Xcsb
            //{

            //    public static class Charactor
            //    {
            //        public static IXCProto Dismember(this Xcsb.IXProto client)
            //        {
            //            return new XCpo();
            //        }
            //    }
            //}

            //""");
            //            });

        }


        static IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol @namespace)
        {
            foreach (var member in @namespace.GetMembers())
            {
                if (member is INamespaceSymbol nestedNs)
                {
                    foreach (var type in GetAllTypes(nestedNs))
                        yield return type;
                }
                else if (member is INamedTypeSymbol type)
                {
                    yield return type;
                }
            }
        }

    }
}
